# Banque PL/SQL â€” Projet Oracle
### Auteur : HANI Sidi-Walid  

---

## ğŸ¯ Introduction

Ce projet a Ã©tÃ© rÃ©alisÃ© dans le cadre dâ€™un **D'une modÃ©lisation et dÃ©veloppement dâ€™un systÃ¨me bancaire** sous Oracle.  
Lâ€™objectif Ã©tait de concevoir une base de donnÃ©es **relationnelle robuste** et des **packages PL/SQL modulaires** permettant la gestion des clients, comptes, transactions, prÃªts, paiements et rÃ©conciliations.  

Ce document dÃ©crit **comment jâ€™ai rÃ©pondu procÃ©der**, en expliquant les choix techniques et les vÃ©rifications effectuÃ©es.  

---

## ğŸ§± 1. CrÃ©ation du schÃ©ma relationnel

CrÃ©er toutes les tables nÃ©cessaires avec les contraintes PK, FK, NOT NULL, CHECK et UNIQUE.  

- `CLIENT` : stocke les informations personnelles (nom, prÃ©nom, adresse, tÃ©lÃ©phone, e-mail, statut KYC).  
- `COMPTE` : contient les comptes bancaires liÃ©s Ã  chaque client.  
- `TXN` : trace les transactions internes entre comptes (dÃ©bit/crÃ©dit).  
- `GL` : journal gÃ©nÃ©ral des Ã©critures comptables.  
- `PAIEMENT_IN` : gÃ¨re les fichiers de paiements entrants.  
- `PRODUIT_PRET`, `PRET`, `ECHEANCE` : pour la gestion des prÃªts et Ã©chÃ©anciers.  
- `EXT_CONF`, `RECON_EX` : pour la rÃ©conciliation interne â†” externe.  
- `STP_ETAT` : journal de traitement automatique (Straight Through Processing).  
- `AUDIT_LOG` : historique des Ã©vÃ©nements.  

Chaque table a Ã©tÃ© crÃ©Ã©e dans le fichier **`01_Schema.sql`**, en appliquant les contraintes de clÃ© primaire, clÃ©s Ã©trangÃ¨res, index, et unicitÃ© (comme `UQ_CLIENT_EMAIL`).  

---

## ğŸ”‘ 2. Contraintes et intÃ©gritÃ© rÃ©fÃ©rentielle

### Objectif :
Mettre en place des contraintes dâ€™intÃ©gritÃ© et vÃ©rifier leur validitÃ©.  

### Conception :
Jâ€™ai utilisÃ© des **FK** pour relier les entitÃ©s principales :  
- `COMPTE.CLIENT_ID â†’ CLIENT.ID`  
- `PRET.COMPTE_ID â†’ COMPTE.ID`  
- `ECHEANCE.PRET_ID â†’ PRET.ID`  
- `GL.ID_TXN â†’ TXN.ID_TXN`  
- `PAIEMENT_IN` reliÃ© Ã  `TXN` via `ID_TXN` lors de la validation.  

Une fois crÃ©Ã©es, jâ€™ai vÃ©rifiÃ© leur prÃ©sence :  
```sql
select constraint_name, table_name, constraint_type
from user_constraints
order by table_name;
```

---

## ğŸ’¾ 3. Insertion des donnÃ©es de dÃ©monstration

### Objectif :
InsÃ©rer des donnÃ©es clients, comptes, prÃªts et paiements pour tester les modules.  

### Conception :
Dans le fichier **`11_Donnees_Demo.sql`**, jâ€™ai ajoutÃ© des donnÃ©es rÃ©alistes :  
- Clients (Durand, Bernard, Dupont...) avec adresses et e-mails.  
- Comptes associÃ©s (`AL-001`, `BO-001`, etc.) avec devises et soldes.  
- Un produit de prÃªt standard et un prÃªt actif liÃ© au compte de Durand.  
- Des paiements entrants simulant des virements externes.  

Jâ€™ai vÃ©rifiÃ© les insertions par :  
```sql
select nom, prenom, ville from client;
select numero, solde from compte;
select * from paiement_in;
```

---

## ğŸ§® 4. CrÃ©ation des vues et utilisation des jointures

### Objectif :
CrÃ©er des vues de reporting utilisant les **jointures SQL modernes (JOIN / LEFT JOIN)**.

### Conception :
Jâ€™ai crÃ©Ã© plusieurs vues dans le fichier **`09_Reporting.sql`**, notamment :  

#### Exemple : `V_BALANCE`
Permet de visualiser le solde net de chaque compte.  
```sql
create or replace view v_balance as
select c.numero, c.devise,
       sum(case when g.dc='D' then g.montant else 0 end) as debits,
       sum(case when g.dc='C' then g.montant else 0 end) as credits,
       sum(case when g.dc='C' then g.montant else 0 end) -
       sum(case when g.dc='D' then g.montant else 0 end) as net
from compte c
left join gl g on g.compte_id = c.id
group by c.numero, c.devise;
```

Jâ€™ai aussi utilisÃ© des **jointures internes** et **gauche** dans :
- `v_txn_detail` : jointure entre TXN, COMPTE (dÃ©bit/crÃ©dit), et CLIENT.  
- `v_compte_balance` : jointure entre CLIENT et COMPTE pour afficher le solde total du client.  

---

## ğŸ’° 5. Transactions et idempotence (Package Comptable)

### Objectif :
ImplÃ©menter les virements inter-comptes et garantir quâ€™ils ne soient jamais doublÃ©s.

### Conception :
Dans **`03_Package_Comptable.sql`**, jâ€™ai crÃ©Ã© les procÃ©dures :
- `virement` : transfert sÃ©curisÃ© entre comptes avec mise Ã  jour des soldes et journalisation dans `GL`.
- `frais` et `annuler` : pour les frais bancaires et les annulations.  

Jâ€™ai validÃ© lâ€™idempotence :
```sql
exec pkg_comptable.virement('TX-001', 1, 2, 100, 'EUR');
exec pkg_comptable.virement('TX-001', 1, 2, 100, 'EUR'); -- ne double pas
select * from gl where id_txn='TX-001';
```

---

## ğŸ’¸ 6. Paiements et pipeline STP

### Objectif :
Charger, valider et poster automatiquement les paiements dâ€™un fichier.

### Conception :
Packages concernÃ©s : `pkg_paiement` et `pkg_stp`.  
- **`pkg_paiement.valider`** vÃ©rifie les numÃ©ros de compte et les montants.  
- **`pkg_paiement.poster`** gÃ©nÃ¨re les transactions dans `TXN`.  
- **`pkg_stp.paiement_csv`** orchestre tout le pipeline automatique.  

```sql
begin
  pkg_stp.paiement_csv('F01');
end;
/
select fichier, statut, id_txn from paiement_in;
```

---

## ğŸ¦ 7. Gestion des prÃªts et Ã©chÃ©anciers

### Objectif :
Mettre en place la gÃ©nÃ©ration dâ€™Ã©chÃ©ancier et le prÃ©lÃ¨vement des mensualitÃ©s.

### Conception :
Dans **`06_Package_Pret.sql`**, jâ€™ai implÃ©mentÃ© :
- `generer_echeancier` â†’ calcule les intÃ©rÃªts et mensualitÃ©s.
- `prelever` â†’ dÃ©bite la mensualitÃ© et crÃ©dite le compte GL_INTERETS.
- `penalite_retard` â†’ applique une pÃ©nalitÃ© en cas de retard.  

Test de la gÃ©nÃ©ration :
```sql
exec pkg_pret.generer_echeancier(1);
select * from echeance where pret_id=1;
```

---

## ğŸ”„ 8. RÃ©conciliation interne â†” externe

### Objectif :
Comparer les transactions internes (TXN) et externes (EXT_CONF).

### Conception :
ImplÃ©mentÃ© dans **`07_Package_Reconciliation.sql`** :
```sql
exec pkg_recon.charger('E-001','PAY-9',50);
exec pkg_recon.comparer;
select * from recon_ex;
```
Les types dâ€™Ã©carts identifiÃ©s :
- `ABSENT_EXT` : transaction interne non confirmÃ©e.  
- `ABSENT_INT` : transaction externe non trouvÃ©e.  
- `ECART` : diffÃ©rence de montant.

---

## ğŸ“Š 9. Reporting global et vÃ©rifications

### Objectif :
CrÃ©er des vues synthÃ©tiques et vÃ©rifier les donnÃ©es consolidÃ©es.

### Conception :
Jâ€™ai produit plusieurs vues pour le reporting :
```sql
select * from v_client;
select * from v_balance order by net desc;
select * from v_txn_detail where statut='POSTE';
```
RÃ©sultat : cohÃ©rence totale entre soldes, transactions et paiements.

---

## ğŸ§¹ 10. Nettoyage et maintenance

### Objectif :
Ajouter un script pour purger les donnÃ©es de test.

### Conception :
Le fichier **`13_Nettoyage.sql`** vide toutes les tables dans le bon ordre :
```sql
begin
  delete from gl;
  delete from paiement_in;
  delete from txn;
  delete from pret;
  delete from compte;
  delete from client;
  commit;
end;
/
```

---

## ğŸ§  Conclusion


âœ” CrÃ©ation du schÃ©ma complet avec contraintes.  
âœ” Jointures SQL modernes (INNER / LEFT).  
âœ” Packages modulaires pour chaque domaine mÃ©tier.  
âœ” DonnÃ©es de test validÃ©es et cohÃ©rentes.  
âœ” RÃ©conciliation, audit et reporting opÃ©rationnels.  

Le rÃ©sultat final est une **solution bancaire complÃ¨te, stable et Ã©volutive**, prÃªte Ã  Ãªtre dÃ©ployÃ©e sous Oracle.

---

**HANI Sidi-Walid**  
Projet PL/SQL Bancaire â€” Oracle 21c  
